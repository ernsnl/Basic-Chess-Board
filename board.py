import itertools
from enums import Piece, Color
from board_location import BoardLocation
from helper import print_possible_moves, assign_piece, append_list

"""
Main Chess Board class

self.board ==> the actual text of the board that is given by the user
self.board_matrix ==> Matrix of BoardLocation instances
"""


class Board():

    def __init__(self, board):
        self.board_text = board
        self.board_matrix = self.create_board()

    def __str__(self):
        print_str = ''
        row_count = 8
        for row in self.board_matrix:
            print_str += str(row_count)
            row_count -= 1
            for col in row:
                print_str += str(col)
            print_str += '\n'
        print_str += ' A B C D E F G H'
        return print_str

    def create_board(self):
        """ Returns a 8*8 BoardLocation matrix
        Matrix is generated by board_text value of the instance
        """
        chess_board = []
        for row in range(len(self.board_text)):
            chess_row = []
            empty_buffer = 0
            for col in range(len(self.board_text[row])):
                if (self.board_text[row][col]).isdigit():
                    # Empty Spaces in the Chess Board
                    chess_row.extend([BoardLocation(row, col)
                                      for _ in range(int(self.board_text[row][col]))])
                    empty_buffer += int(self.board_text[row][col]) - 1
                elif (self.board_text[row][col]).islower():
                    # Black Pieces in the Chess Board
                    chess_row.append(assign_piece(
                        row, col + empty_buffer, self.board_text[row][col], Color.BLACK))
                else:
                    # White Pieces in the Chess Board
                    chess_row.append(assign_piece(
                        row, col + empty_buffer, self.board_text[row][col].lower(), Color.WHITE))
            chess_board.append(chess_row)
        return chess_board

    def possible_moves(self, color):
        """Iterates over the board_matrix and
           generates possible moves that player with color can play"""
        for row in self.board_matrix:
            for col in row:
                if not col.empty and col.color == color:
                    moves = []
                    if col.piece == Piece.BISHOP:
                        moves = self.get_diagonal_move(col)
                    if col.piece == Piece.ROOK:
                        moves = self.get_vertical_move(col)
                    if col.piece == Piece.QUEEN:
                        moves = self.get_vertical_move(col)
                        moves.extend(self.get_diagonal_move(col))
                    if col.piece == Piece.KING:
                        moves = self.get_vertical_move(col,1)
                        moves.extend(self.get_diagonal_move(col,1))
                    if col.piece == Piece.PAWN:
                        moves = self.get_pawn_move(col)
                    if col.piece == Piece.NIGHT:
                        moves = self.get_knight_move(col)

                    if len(moves) > 0:
                        print(self)
                        print_possible_moves(col, moves)
                        input("Press Enter to continue...")
                        print(chr(27) + "[2J")

    def get_diagonal_move(self, piece_info, length=-1):
        """Returns all the possible diagonal moves that can be played by using that piece
        Has a optional parameter of length which defines how long a piece can go from its starting position
        """
        possible_moves = []
        if length == -1:
            length = 8
        length += 1
        # Right Up Move
        for _ in range(1, length):
            if piece_info.row - _ < 0 or piece_info.col + _ > 7:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row - _, piece_info.col + _, piece_info)), possible_moves)
            if not breaking:
                break
        # Right Down Move
        for _ in range(1, length):
            if piece_info.row + _ > 7 or piece_info.col + _ > 7:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row + _, piece_info.col + _, piece_info)), possible_moves)
            if not breaking:
                break
        # Left Up Move
        for _ in range(1, length):
            if piece_info.row - _ < 0 or piece_info.col - _ < 0:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row - _, piece_info.col - _, piece_info)), possible_moves)
            if not breaking:
                break
        # Left Down Move
        for _ in range(1, length):
            if piece_info.row + _ > 7 or piece_info.col - _ < 0:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row + _, piece_info.col - _, piece_info)), possible_moves)
            if not breaking:
                break

        return possible_moves

    def get_vertical_move(self, piece_info, length=-1):
        """Returns all the possible vertical and Horizontal moves that can be played by using that piece
        Has a optional parameter of length which defines how long a piece can go from its starting position
        """
        possible_moves = []
        if length == -1:
            length = 8
        length += 1
        # Vertical Up
        for _ in range(1, length):
            if piece_info.row - _ < 0:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row - _, piece_info.col, piece_info)), possible_moves)
            if not breaking:
                break
        # Vertical Down
        for _ in range(1, length):
            if piece_info.row + _ > 7:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row + _, piece_info.col, piece_info)), possible_moves)
            if not breaking:
                break
        # Horizontal Left
        for _ in range(1, length):
            if piece_info.col - _ < 0:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row, piece_info.col - _, piece_info)), possible_moves)
            if not breaking:
                break
        # Horizontal Right
        for _ in range(1, length):
            if piece_info.col + _ > 7:
                break
            possible_moves, breaking = append_list((self.general_possible_move(
                piece_info.row, piece_info.col + _, piece_info)), possible_moves)
            if not breaking:
                break

        return possible_moves

    def get_pawn_move(self, piece_info):
        """Returns all the possible pawn moves that can be played by using that pawn
        """
        possible_moves = []
        row = piece_info.row
        col = piece_info.col
        if piece_info.color == Color.BLACK and row < 7:
            if self.board_matrix[row + 1][col].empty:
                possible_moves.append((row + 1, col))
                # Checking the opening of the
                if row == 1 and self.board_matrix[row + 2][col].empty:
                    possible_moves.append((row + 2, col))
            if col + 1 < 8 and not self.board_matrix[row + 1][col + 1].empty and self.board_matrix[row + 1][col + 1].color != piece_info.color:
                possible_moves.append((row + 1, col + 1,'x'))
            if col - 1 > -1 and not self.board_matrix[row + 1][col - 1].empty and self.board_matrix[row + 1][col - 1].color != piece_info.color:
                possible_moves.append((row + 1, col - 1,'x'))
        elif piece_info.color == Color.WHITE and row > 0:
            if self.board_matrix[row - 1][col].empty:
                possible_moves.append((row - 1, col))
                if row == 6 and self.board_matrix[row - 2][col].empty:
                    possible_moves.append((row - 2, col))
            if col + 1 < 8 and not self.board_matrix[row - 1][col + 1].empty and self.board_matrix[row - 1][col + 1].color != piece_info.color:
                possible_moves.append((row - 1, col + 1,'x'))
            if col - 1 > -1 and not self.board_matrix[row - 1][col - 1].empty and self.board_matrix[row - 1][col - 1].color != piece_info.color:
                possible_moves.append((row - 1, col - 1,'x'))
        return possible_moves

    def get_knight_move(self, piece_info):
        """Returns all the possible night moves that can be played by using that night
        """
        possible_moves = []
        temp_moves = []
        row = piece_info.row
        col = piece_info.col
        a = [x for x in range(-1,2,2)]
        b = [y for y in range(-2,3,4)]
        temp_moves.extend(list(itertools.product(a,b)))
        temp_moves.extend(list(itertools.product(b,a)))
        for mov in temp_moves:
            movement_row = mov[0] + row
            movement_col = mov[1] + col
            if movement_row > 7 or movement_row < 0:
                continue
            elif movement_col > 7 or movement_col < 0:
                continue
            else:
                move_it = self.general_possible_move(movement_row, movement_col, piece_info)
                if move_it is None:
                    continue
                else:
                    possible_moves.append(move_it)
        return possible_moves





    def general_possible_move(self, row, col, piece_info):
        possible_move = None
        if self.board_matrix[row][col].empty:
            possible_move = (row, col)
        else:
            if self.board_matrix[row][col].color != piece_info.color:
                possible_move = (row, col, 'x')
        return possible_move
